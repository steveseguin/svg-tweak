<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/utils/BufferGeometryUtils.js"></script>
    <title>SVG to STL Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .drop-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin: 20px 0;
            transition: border 0.3s;
            cursor: pointer;
        }
        .drop-area.highlight {
            border-color: #4CAF50;
        }
        .file-input {
            display: none;
        }
        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        .btn:hover {
            background-color: #45a049;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .preview-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .preview-box {
            flex: 1;
            margin: 0 10px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
            height: 400px;
            overflow: hidden;
            position: relative;
        }
        .preview-box h3 {
            margin-top: 0;
            text-align: center;
        }
        #svg-preview {
            width: 100%;
            height: 340px;
            background-color: #fff;
        }
        #stl-preview {
            width: 100%;
            height: 340px;
            background-color: #fff;
        }
        .settings {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .settings-label {
            flex: 0 0 150px;
        }
        input[type="range"] {
            flex: 1;
        }
        input[type="number"] {
            width: 60px;
            margin-left: 10px;
            padding: 3px;
        }
        /* New styles for mode toggle */
        .toggle-container {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
            margin: 0 10px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #4CAF50;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(32px);
        }
        .toggle-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SVG to STL Converter</h1>
        
        <div id="drop-area" class="drop-area">
            <p>Drag & drop your SVG file here, or</p>
            <input type="file" id="file-input" class="file-input" accept=".svg">
            <button class="btn" onclick="document.getElementById('file-input').click()">Select File</button>
            <p style="margin-top: 15px;">Or paste SVG code:</p>
            <button class="btn" onclick="toggleSvgTextarea()">Paste SVG</button>
        </div>
        
        <div id="svg-textarea-container" style="display: none; margin: 15px 0;">
            <textarea id="svg-textarea" style="width: 100%; height: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="Paste your SVG code here..."></textarea>
            <div style="text-align: right; margin-top: 5px;">
                <button class="btn" onclick="processPastedSVG()">Process SVG</button>
            </div>
        </div>
        
        <div class="settings">
            <h3>Conversion Mode</h3>
            <div class="toggle-container">
                <span class="toggle-label">Volume Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">Line Mode</span>
            </div>
            <p id="mode-description" style="margin-top: 5px; font-size: 14px; color: #666;">
                Volume Mode: Filled areas become solid, empty areas become holes.
            </p>
            
            <h3>Extrusion Settings</h3>
            <div class="settings-row">
                <label class="settings-label" for="extrusion-height">Extrusion Height:</label>
                <input type="range" id="extrusion-height" min="0.00001" step="0.001" max="50" value="1" oninput="this.nextElementSibling.value = this.value">
                <input type="number" min="0.00001"  max="50" value="1" oninput="this.previousElementSibling.value = this.value">
            </div>
            <div class="settings-row">
                <label class="settings-label" for="base-thickness">Base Thickness:</label>
                <input type="range" id="base-thickness" min="0" max="10" value="2" oninput="this.nextElementSibling.value = this.value">
                <input type="number" min="0" max="10" value="2" oninput="this.previousElementSibling.value = this.value">
            </div>
            <div class="settings-row">
                <label class="settings-label" for="resolution">Resolution:</label>
                <input type="range" id="resolution" min="1" max="10" value="5" oninput="this.nextElementSibling.value = this.value">
                <input type="number" min="1" max="10" value="5" oninput="this.previousElementSibling.value = this.value">
            </div>
        </div>
        
        <div class="btn-container" style="text-align: center;">
            <button id="convert-btn" class="btn" disabled>Convert to STL</button>
            <button id="download-btn" class="btn" disabled>Download STL</button>
        </div>
        
        <div class="preview-container">
            <div class="preview-box">
                <h3>SVG Preview</h3>
                <div id="svg-preview"></div>
            </div>
            <div class="preview-box">
                <h3>STL Preview</h3>
                <div id="stl-preview"></div>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    
    <script>
        // DOM elements
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const convertBtn = document.getElementById('convert-btn');
        const downloadBtn = document.getElementById('download-btn');
        const svgPreview = document.getElementById('svg-preview');
        const stlPreview = document.getElementById('stl-preview');
        const modeToggle = document.getElementById('mode-toggle');
        const modeDescription = document.getElementById('mode-description');
        
        // State variables
        let svgContent = null;
        let stlContent = null;
        let svgPaths = [];
        let svgViewBox = { x: 0, y: 0, width: 100, height: 100 };
        let scene = null; // Global scene reference
        let isLineMode = false; // Default to Volume Mode
        
        // Mode toggle event listener
        modeToggle.addEventListener('change', function() {
            isLineMode = this.checked;
            if (isLineMode) {
                modeDescription.textContent = 'Line Mode: Lines are treated as boundaries, thickness is ignored.';
            } else {
                modeDescription.textContent = 'Volume Mode: Filled areas become solid, empty areas become holes.';
            }
            
            // Re-parse SVG if we have content
            if (svgContent) {
                parseSVG(svgContent);
            }
        });
        
        // SVG Textarea toggle
        function toggleSvgTextarea() {
            const container = document.getElementById('svg-textarea-container');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                document.getElementById('svg-textarea').focus();
            } else {
                container.style.display = 'none';
            }
        }
        
        // Process pasted SVG
        function processPastedSVG() {
            const textarea = document.getElementById('svg-textarea');
            const svgCode = textarea.value.trim();
            
            if (!svgCode) {
                alert('Please paste SVG code');
                return;
            }
            
            if (!svgCode.includes('<svg') || !svgCode.includes('</svg>')) {
                alert('Invalid SVG code. Make sure to include the <svg> tag.');
                return;
            }
            
            svgContent = svgCode;
            displaySVG(svgContent);
            parseSVG(svgContent);
            convertBtn.disabled = false;
            
            // Hide textarea after processing
            document.getElementById('svg-textarea-container').style.display = 'none';
        }
        
        // Handle drag and drop events
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.classList.add('highlight');
        }
        
        function unhighlight() {
            dropArea.classList.remove('highlight');
        }
        
        // Handle file drops
        dropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }
        
        fileInput.addEventListener('change', function() {
            handleFiles(this.files);
        });
        
        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'image/svg+xml') {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        svgContent = e.target.result;
                        displaySVG(svgContent);
                        parseSVG(svgContent);
                        convertBtn.disabled = false;
                    };
                    reader.readAsText(file);
                } else {
                    alert('Please upload an SVG file.');
                }
            }
        }
        
        function displaySVG(svgString) {
            svgPreview.innerHTML = svgString;
            // Make sure the SVG scales to fit the preview area
            const svgElement = svgPreview.querySelector('svg');
            if (svgElement) {
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';
            }
        }
        
        // Helper function to create path data for rounded rectangle
        function createRoundedRectPath(x, y, width, height, radius) {
            return `M${x + radius},${y}
                    L${x + width - radius},${y}
                    A${radius},${radius} 0 0 1 ${x + width},${y + radius}
                    L${x + width},${y + height - radius}
                    A${radius},${radius} 0 0 1 ${x + width - radius},${y + height}
                    L${x + radius},${y + height}
                    A${radius},${radius} 0 0 1 ${x},${y + height - radius}
                    L${x},${y + radius}
                    A${radius},${radius} 0 0 1 ${x + radius},${y}
                    Z`;
        }

        function createShapeFromPathData(shape, pathData, scale) {
          // Parse SVG path data and create a Three.js shape
          const commands = parseSVGPath(pathData);
          let firstCommand = true;
          
          commands.forEach(cmd => {
              const type = cmd.type;
              const args = cmd.args.map(arg => arg * scale);
              
              switch(type) {
                  case 'M': // Move to (absolute)
                      shape.moveTo(args[0], -args[1]); // Note Y-axis flip for Three.js
                      break;
                  case 'm': // Move to (relative)
                      if (firstCommand) {
                          shape.moveTo(args[0], -args[1]);
                      } else {
                          const currentPoint = shape.currentPoint;
                          shape.moveTo(currentPoint.x + args[0], currentPoint.y - args[1]);
                      }
                      break;
                  case 'L': // Line to (absolute)
                      shape.lineTo(args[0], -args[1]);
                      break;
                  case 'l': // Line to (relative)
                      const currentPoint = shape.currentPoint;
                      shape.lineTo(currentPoint.x + args[0], currentPoint.y - args[1]);
                      break;
                  case 'H': // Horizontal line (absolute)
                      shape.lineTo(args[0], shape.currentPoint.y);
                      break;
                  case 'h': // Horizontal line (relative)
                      shape.lineTo(shape.currentPoint.x + args[0], shape.currentPoint.y);
                      break;
                  case 'V': // Vertical line (absolute)
                      shape.lineTo(shape.currentPoint.x, -args[0]);
                      break;
                  case 'v': // Vertical line (relative)
                      shape.lineTo(shape.currentPoint.x, shape.currentPoint.y - args[0]);
                      break;
                  case 'C': // Cubic curve (absolute)
                      shape.bezierCurveTo(
                          args[0], -args[1],
                          args[2], -args[3],
                          args[4], -args[5]
                      );
                      break;
                  case 'c': // Cubic curve (relative)
                      const cp = shape.currentPoint;
                      shape.bezierCurveTo(
                          cp.x + args[0], cp.y - args[1],
                          cp.x + args[2], cp.y - args[3],
                          cp.x + args[4], cp.y - args[5]
                      );
                      break;
                  case 'Q': // Quadratic curve (absolute)
                      shape.quadraticCurveTo(
                          args[0], -args[1],
                          args[2], -args[3]
                      );
                      break;
                  case 'q': // Quadratic curve (relative)
                      const qp = shape.currentPoint;
                      shape.quadraticCurveTo(
                          qp.x + args[0], qp.y - args[1],
                          qp.x + args[2], qp.y - args[3]
                      );
                      break;
                  case 'A': // Arc (absolute)
                      // Simplified arc handling - convert to curve
                      const arc = approximateArc(
                          shape.currentPoint.x, shape.currentPoint.y,
                          args[0], args[1], args[2], args[3], args[4], args[5], -args[6]
                      );
                      arc.forEach(point => {
                          shape.lineTo(point.x, point.y);
                      });
                      break;
                  case 'Z':
                  case 'z':
                      shape.closePath();
                      break;
              }
              
              firstCommand = false;
          });
      }

        function updateExtrusionSettings(viewBox) {
    if (!viewBox) return;
    
    // Calculate appropriate extrusion height range based on SVG dimensions
    const maxDimension = Math.max(viewBox.width, viewBox.height)/100;
    const defaultHeight = Math.max(0.0001, Math.round(maxDimension * 0.05)); // 5% of max dimension
    
    // Update extrusion height slider
    const extrusionHeightSlider = document.getElementById('extrusion-height');
    const extrusionHeightValue = document.getElementById('extrusion-height').nextElementSibling;
    
    //extrusionHeightSlider.min = "0.1";
    extrusionHeightSlider.max = Math.round(maxDimension * 0.5); // 50% of max dimension
    extrusionHeightSlider.value = defaultHeight;
    extrusionHeightValue.value = defaultHeight;
    
    // Also update base thickness to be proportional
    const baseThicknessSlider = document.getElementById('base-thickness');
    const baseThicknessValue = document.getElementById('base-thickness').nextElementSibling;
    
    const defaultBase = Math.max(0.5, Math.round(maxDimension * 0.01)); // 1% of max dimension
    baseThicknessSlider.min = "0";
    baseThicknessSlider.max = Math.round(maxDimension * 0.1); // 10% of max dimension
    baseThicknessSlider.value = defaultBase;
    baseThicknessValue.value = defaultBase;
}
        
      function parseSVG(svgString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, 'image/svg+xml');
        const svg = doc.querySelector('svg');
        
        // Extract viewBox
        if (svg.getAttribute('viewBox')) {
            const viewBoxValues = svg.getAttribute('viewBox').split(' ');
            svgViewBox = {
                x: parseFloat(viewBoxValues[0]),
                y: parseFloat(viewBoxValues[1]),
                width: parseFloat(viewBoxValues[2]),
                height: parseFloat(viewBoxValues[3])
            };
        } else if (svg.getAttribute('width') && svg.getAttribute('height')) {
            svgViewBox = {
                x: 0,
                y: 0,
                width: parseFloat(svg.getAttribute('width')),
                height: parseFloat(svg.getAttribute('height'))
            };
        }

        updateExtrusionSettings(svgViewBox);
        
        // Structure to hold paths and their types (outer contours vs holes)
        svgPaths = [];
        
        // Extract all elements that can define shapes
        const pathElements = svg.querySelectorAll('path');
        const rectElements = svg.querySelectorAll('rect');
        const circleElements = svg.querySelectorAll('circle');
        const lineElements = svg.querySelectorAll('line');
        const polylineElements = svg.querySelectorAll('polyline');
        const polygonElements = svg.querySelectorAll('polygon');
        
        // Process paths
        pathElements.forEach(path => {
            let isHole = isLineMode ? false : determineIfHole(path);
            svgPaths.push({
                pathData: path.getAttribute('d'),
                isHole: isHole,
                strokeWidth: parseFloat(path.getAttribute('stroke-width') || 1),
                element: path
            });
        });
        
        // Process rectangles
        rectElements.forEach(rect => {
            const x = parseFloat(rect.getAttribute('x') || 0);
            const y = parseFloat(rect.getAttribute('y') || 0);
            const width = parseFloat(rect.getAttribute('width'));
            const height = parseFloat(rect.getAttribute('height'));
            const rx = parseFloat(rect.getAttribute('rx') || 0);
            const ry = parseFloat(rect.getAttribute('ry') || 0);
            
            let pathData;
            if (rx || ry) {
                // Handle rounded rectangles
                const r = rx || ry;
                pathData = createRoundedRectPath(x, y, width, height, r);
            } else {
                // Simple rectangle
                pathData = `M${x},${y} h${width} v${height} h-${width} Z`;
            }
            
            let isHole = isLineMode ? false : determineIfHole(rect);
            svgPaths.push({
                pathData: pathData,
                isHole: isHole,
                strokeWidth: parseFloat(rect.getAttribute('stroke-width') || 1),
                element: rect
            });
        });
        
        // Process circles
        circleElements.forEach(circle => {
            const cx = parseFloat(circle.getAttribute('cx'));
            const cy = parseFloat(circle.getAttribute('cy'));
            const r = parseFloat(circle.getAttribute('r'));
            
            // Approximate circle with a path
            const pathData = `M${cx+r},${cy} 
                            A${r},${r} 0 0 1 ${cx},${cy-r} 
                            A${r},${r} 0 0 1 ${cx-r},${cy} 
                            A${r},${r} 0 0 1 ${cx},${cy+r} 
                            A${r},${r} 0 0 1 ${cx+r},${cy} Z`;
            
            let isHole = isLineMode ? false : determineIfHole(circle);
            svgPaths.push({
                pathData: pathData,
                isHole: isHole,
                strokeWidth: parseFloat(circle.getAttribute('stroke-width') || 1),
                element: circle
            });
        });
        
        // In Line Mode, also process lines and convert to paths with thickness
        if (isLineMode) {
            // Process lines
            lineElements.forEach(line => {
                const x1 = parseFloat(line.getAttribute('x1'));
                const y1 = parseFloat(line.getAttribute('y1'));
                const x2 = parseFloat(line.getAttribute('x2'));
                const y2 = parseFloat(line.getAttribute('y2'));
                const strokeWidth = parseFloat(line.getAttribute('stroke-width') || 1);
                
                // Create a path from the line with thickness
                const pathData = createLinePathWithThickness(x1, y1, x2, y2, strokeWidth);
                
                svgPaths.push({
                    pathData: pathData,
                    isHole: false,
                    strokeWidth: strokeWidth,
                    element: line
                });
            });
            
            // Process polylines
            polylineElements.forEach(polyline => {
                const points = polyline.getAttribute('points').trim().split(/\s+|,/);
                const strokeWidth = parseFloat(polyline.getAttribute('stroke-width') || 1);
                
                // Create a path from the polyline with thickness
                let pathData = '';
                for (let i = 0; i < points.length - 2; i += 2) {
                    const x1 = parseFloat(points[i]);
                    const y1 = parseFloat(points[i+1]);
                    const x2 = parseFloat(points[i+2]);
                    const y2 = parseFloat(points[i+3]);
                    
                    if (i === 0) {
                        // Starting segment
                        pathData = createLinePathWithThickness(x1, y1, x2, y2, strokeWidth);
                    } else {
                        // Continuing segments, append path
                        pathData += createLinePathWithThickness(x1, y1, x2, y2, strokeWidth, true);
                    }
                }
                
                svgPaths.push({
                    pathData: pathData,
                    isHole: false,
                    strokeWidth: strokeWidth,
                    element: polyline
                });
            });
            
            // Process polygons
            polygonElements.forEach(polygon => {
                const points = polygon.getAttribute('points').trim().split(/\s+|,/);
                const fillColor = polygon.getAttribute('fill');
                let isHole = false;
                
                if (fillColor === 'none' || fillColor === '#fff' || fillColor === '#ffffff' || fillColor === 'white') {
                    isHole = true;
                }
                
                // Create a path from the polygon
                let pathData = `M${points[0]},${points[1]}`;
                for (let i = 2; i < points.length; i += 2) {
                    pathData += ` L${points[i]},${points[i+1]}`;
                }
                pathData += ' Z';
                
                svgPaths.push({
                    pathData: pathData,
                    isHole: isHole,
                    strokeWidth: parseFloat(polygon.getAttribute('stroke-width') || 1),
                    element: polygon
                });
            });
        }
        
        console.log('Parsed SVG with', svgPaths.length, 'paths/shapes');
        console.log('Holes:', svgPaths.filter(p => p.isHole).length);
        console.log('Outer contours:', svgPaths.filter(p => !p.isHole).length);
        console.log('Mode:', isLineMode ? 'Line Mode' : 'Volume Mode');
    }
    
    // Helper function to create a path for a line with thickness
    function createLinePathWithThickness(x1, y1, x2, y2, thickness, isSegment = false) {
        // Calculate perpendicular direction for thickness
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate offset perpendicular to the line direction
        const halfThickness = thickness / 2;
        const offsetX = (dy / length) * halfThickness;
        const offsetY = -(dx / length) * halfThickness;
        
        // Calculate the four corners of the thick line
        const x1Left = x1 - offsetX;
        const y1Left = y1 - offsetY;
        const x1Right = x1 + offsetX;
        const y1Right = y1 + offsetY;
        const x2Left = x2 - offsetX;
        const y2Left = y2 - offsetY;
        const x2Right = x2 + offsetX;
        const y2Right = y2 + offsetY;
        
        if (isSegment) {
            // For continuing segments, just return the right side path
            return `L${x2Left},${y2Left} L${x2Right},${y2Right}`;
        } else {
            // For a complete path, create a closed rectangular path
            return `M${x1Left},${y1Left} L${x2Left},${y2Left} L${x2Right},${y2Right} L${x1Right},${y1Right} Z`;
        }
    }
      
    // Parse SVG path data string into commands
    function parseSVGPath(pathData) {
        const commands = [];
        const pathParser = /([MmLlHhVvCcSsQqTtAaZz])([^MmLlHhVvCcSsQqTtAaZz]*)/g;
        let match;
        
        while ((match = pathParser.exec(pathData)) !== null) {
            const type = match[1];
            const argsStr = match[2].trim();
            let args = [];
            
            if (argsStr) {
                // Handle both comma and space separated values
                args = argsStr.replace(/,/g, ' ')
                            .split(/\s+/)
                            .map(parseFloat)
                            .filter(arg => !isNaN(arg));
            }
            
            commands.push({ type, args });
        }
        
        return commands;
    }
      
    // Create points to approximate an arc
    function approximateArc(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2) {
        // Convert angle from degrees to radians
        angle = angle * Math.PI / 180;
        
        // Simple approximation - just return end point for now
        // For a more accurate implementation, additional math would be needed
        return [{ x: x2, y: y2 }];
    }
      
    function determineIfHole(element) {
        // In Line Mode, we don't consider anything as a hole inherently
        if (isLineMode) {
            return false;
        }
        
        // Check if the element has explicit hole markers
        if (element.getAttribute('data-hole') === 'true') {
            return true;
        }
        
        // Check fill attribute - no fill or white fill often indicates a hole
        const fill = element.getAttribute('fill');
        if (fill === 'none' || fill === '#fff' || fill === '#ffffff' || fill === 'white') {
            return true;
        }
        
        // Check for path direction - clockwise paths are typically outer contours,
        // counter-clockwise paths are typically holes in SVG
        if (element.tagName.toLowerCase() === 'path') {
            const pathData = element.getAttribute('d');
            if (pathData && isCounterClockwise(pathData)) {
                return true;
            }
        }
        
        // For small circles with stroke, assume they're mounting holes
        if (element.tagName.toLowerCase() === 'circle') {
            const r = parseFloat(element.getAttribute('r'));
            if (r < 10 && element.getAttribute('stroke')) {
                return true;
            }
        }
        
        // Default to not being a hole
        return false;
    }
      
    // Simplified check for counter-clockwise paths (for holes)
    function isCounterClockwise(pathData) {
        // This is a simplification - for a proper implementation,
        // calculate the signed area of the polygon
        // Counter-clockwise paths have negative signed area
        
        // For now, return false to treat paths as outer contours by default
        return false;
    }
        
    // Convert SVG to STL
    convertBtn.addEventListener('click', convertToSTL);
        
    // Function to detect if one path is inside another
    function isPathInsideAnother(innerPath, outerPath, scale) {
        // Convert paths to points for checking containment
        const innerShape = new THREE.Shape();
        const outerShape = new THREE.Shape();
        
        try {
            createShapeFromPathData(innerShape, innerPath.pathData, scale);
            createShapeFromPathData(outerShape, outerPath.pathData, scale);
            
            // Get a point from the inner shape (using first point)
            const innerPoints = innerShape.getPoints(8);
            if (innerPoints.length === 0) return false;
            
            const testPoint = innerPoints[0];
            
            // Check if this point is inside the outer shape
            return isPointInShape(testPoint, outerShape);
        } catch (e) {
            console.error('Error in path containment check:', e);
            return false;
        }
    }
    
    // Test if a point is inside a shape using ray casting algorithm
    function isPointInShape(point, shape) {
        const shapePoints = shape.getPoints(32);
        let inside = false;
        
        // Ray casting algorithm
        for (let i = 0, j = shapePoints.length - 1; i < shapePoints.length; j = i++) {
            const xi = shapePoints[i].x, yi = shapePoints[i].y;
            const xj = shapePoints[j].x, yj = shapePoints[j].y;
            
            const intersect = ((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                
            if (intersect) inside = !inside;
        }
        
        return inside;
    }
    
    function convertToSTL() {
        if (!svgContent) return;
        
        const extrusionHeight = parseFloat(document.getElementById('extrusion-height').value);
        const baseThickness = parseFloat(document.getElementById('base-thickness').value);
        const resolution = parseFloat(document.getElementById('resolution').value);
        
        // Initialize Three.js scene
        scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(stlPreview.clientWidth, stlPreview.clientHeight);
        renderer.setClearColor(0xf0f0f0);
        
        // Clear previous preview
        stlPreview.innerHTML = '';
        stlPreview.appendChild(renderer.domElement);
        
        // Scale factor to fit the SVG to the preview
        const scale = 0.5 / Math.max(svgViewBox.width, svgViewBox.height);
        
        // Process all paths based on the current mode
        let shapes = [];
        
        if (isLineMode) {
            // In Line Mode, we need to determine containment relationships
            // First, create a map of all paths
            const pathsMap = svgPaths.map((path, index) => ({
                ...path,
                index,
                containedBy: [],
                threeShape: new THREE.Shape()
            }));
            
            // Initialize Three.js shapes for all paths
            pathsMap.forEach(path => {
                try {
                    createShapeFromPathData(path.threeShape, path.pathData, scale);
                } catch (e) {
                    console.error('Error creating shape:', e);
                }
            });
            
            // Build containment hierarchy
            for (let i = 0; i < pathsMap.length; i++) {
                for (let j = 0; j < pathsMap.length; j++) {
                    if (i !== j) {
                        if (isPathInsideAnother(pathsMap[i], pathsMap[j], scale)) {
                            pathsMap[i].containedBy.push(j);
                        }
                    }
                }
            }
            
            // Identify outermost paths (not contained by any other path)
            const outermostPaths = pathsMap.filter(path => path.containedBy.length === 0);
            
            // For each outermost path, identify its direct holes (paths contained by it but by no other path)
            outermostPaths.forEach(outerPath => {
                const shape = outerPath.threeShape;
                
                // Find direct holes for this outer path
                const holes = pathsMap.filter(p => {
                    // A direct hole is contained only by this outer path
                    return p.containedBy.length === 1 && p.containedBy[0] === outerPath.index;
                }).map(holePath => holePath.threeShape);
                
                // Assign holes to the shape
                shape.holes = holes;
                shapes.push(shape);
            });
            
        } else {
            // In Volume Mode, process outer contours and holes
            const outerContours = svgPaths.filter(path => !path.isHole);
            
            if (outerContours.length > 0) {
                // Create shapes from all outer contours
                outerContours.forEach(contour => {
                    const shape = new THREE.Shape();
                    try {
                        createShapeFromPathData(shape, contour.pathData, scale);
                        
                        // Find holes that belong to this contour
                        const holes = svgPaths.filter(path => path.isHole).map(holePath => {
                            const hole = new THREE.Shape();
                            createShapeFromPathData(hole, holePath.pathData, scale);
                            return hole;
                        });
                        
                        // Add holes to the shape
                        shape.holes = holes;
                        shapes.push(shape);
                    } catch (e) {
                        console.error('Error creating shape:', e);
                    }
                });
            }
        }
        
        // If no valid shapes were created, use a fallback
        if (shapes.length === 0) {
            const fallbackShape = new THREE.Shape();
            createFallbackShape(fallbackShape);
            shapes.push(fallbackShape);
        }
        
        // Create a group to hold all the extruded meshes
        const group = new THREE.Group();
        
        // Extrusion settings for solid model
        const extrudeSettings = {
            steps: 1,
            depth: extrusionHeight,
            bevelEnabled: false
        };
        
        // Create extruded geometries for all shapes
        shapes.forEach(shape => {
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshStandardMaterial({
                color: 0x2194ce,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
        });
        
        scene.add(group);
        
        // Center the model
        const box = new THREE.Box3().setFromObject(group);
        const center = box.getCenter(new THREE.Vector3());
        group.position.set(-center.x, -center.y, -extrusionHeight/2);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight2.position.set(-1, -1, 1);
        scene.add(directionalLight2);
        
        // Position camera to better frame the model
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        
        // Add some margin
        cameraZ *= 1.5;
        
        camera.position.z = cameraZ;
        
        // Set up orbit controls for better preview interaction
        setupOrbitControls(camera, renderer);
        
        // Enable download button
        downloadBtn.disabled = false;
        
        // Generate binary STL data
        generateSTLData(group);
    }
        
    // Helper to set up orbit controls
    function setupOrbitControls(camera, renderer) {
        // Cancel any previous animations first
        if (window.previousAnimationFrameId) {
            cancelAnimationFrame(window.previousAnimationFrameId);
        }
        
        let animationFrameId;
        
        if (typeof THREE.OrbitControls !== 'undefined') {
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            controls.zoomSpeed = 1.2;
            controls.enablePan = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.minDistance = 1;
            controls.maxDistance = 1000;
            
            // Add instruction div if it doesn't exist
            let instructionDiv = stlPreview.querySelector('.controls-info');
            if (!instructionDiv) {
                instructionDiv = document.createElement('div');
                instructionDiv.className = 'controls-info';
                instructionDiv.style.position = 'absolute';
                instructionDiv.style.bottom = '10px';
                instructionDiv.style.left = '50%';
                instructionDiv.style.transform = 'translateX(-50%)';
                instructionDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
                instructionDiv.style.color = 'white';
                instructionDiv.style.padding = '5px 10px';
                instructionDiv.style.borderRadius = '4px';
                instructionDiv.style.fontSize = '12px';
                instructionDiv.style.pointerEvents = 'none';
                instructionDiv.textContent = 'Left click: Rotate | Right click: Pan | Scroll: Zoom';
                stlPreview.appendChild(instructionDiv);
            }
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        } else {
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                scene.rotation.x += 0.005;
                scene.rotation.y += 0.005;
                renderer.render(scene, camera);
            }
            animate();
        }
        
        // Store animation reference globally to allow cancellation on next conversion
        window.previousAnimationFrameId = animationFrameId;
        
        // Clean up on window unload
        window.addEventListener('unload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    }
        
    // Create a simple fallback shape if parsing fails
    function createFallbackShape(shape) {
        shape.moveTo(-30, -20);
        shape.lineTo(30, -20);
        shape.lineTo(30, 20);
        shape.lineTo(-30, 20);
        shape.lineTo(-30, -20);
    }
    
    function generateSTLData(group) {
        try {
            // Combine all geometries in the group
            const geometries = [];
            group.traverse(child => {
                if (child instanceof THREE.Mesh) {
                    geometries.push(child.geometry);
                }
            });
            
            if (geometries.length === 0) {
                console.error('No geometries found in group');
                return createFallbackSTL();
            }
            
            // Merge geometries if multiple exist
            let mergedGeometry;
            if (geometries.length > 1) {
                mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);
            } else {
                mergedGeometry = geometries[0];
            }
            
            // The variable 'geometry' is undefined, should be 'mergedGeometry'
            if (!mergedGeometry) {
                console.error('No geometry provided for STL generation');
                return createFallbackSTL();
            }
            
            // Make sure the geometry is a BufferGeometry for STL export
            if (!(mergedGeometry instanceof THREE.BufferGeometry)) {
                mergedGeometry = new THREE.BufferGeometry().fromGeometry(mergedGeometry);
            }
            
            // Get position attribute from geometry
            const positionAttribute = mergedGeometry.getAttribute('position');
            if (!positionAttribute) {
                console.error('Geometry has no position attribute');
                return createFallbackSTL();
            }
            
            // Get normal attribute or compute it if not present
            let normalAttribute = mergedGeometry.getAttribute('normal');
            if (!normalAttribute) {
                mergedGeometry.computeVertexNormals();
                normalAttribute = mergedGeometry.getAttribute('normal');
            }
            
            // Count triangles
            const numTriangles = positionAttribute.count / 3;
            if (numTriangles <= 0) {
                console.error('No triangles in geometry');
                return createFallbackSTL();
            }
            
            console.log(`Generating STL with ${numTriangles} triangles`);
            
            // Create STL binary file
            const headerSize = 80;
            const header = new Uint8Array(headerSize);
            // We could add a text header here if desired
            
            // Calculate the size of the file
            // Header (80 bytes) + Triangle count (4 bytes) + Triangles (50 bytes each)
            const dataSize = 50 * numTriangles;
            const buffer = new ArrayBuffer(headerSize + 4 + dataSize);
            const dataView = new DataView(buffer);
            
            // Fill header (80 bytes)
            const encoder = new TextEncoder();
            const headerText = "SVG to STL conversion by SVG to STL Converter";
            const headerBytes = encoder.encode(headerText);
            for (let i = 0; i < Math.min(headerBytes.length, headerSize); i++) {
                dataView.setUint8(i, headerBytes[i]);
            }
            
            // Write the number of triangles (4 bytes, little-endian)
            dataView.setUint32(headerSize, numTriangles, true);
            
            // Offset for writing triangle data (after header and triangle count)
            let offset = headerSize + 4;
            
            // Position and normal arrays
            const positions = positionAttribute.array;
            const normals = normalAttribute.array;
            
            // For each triangle
            for (let i = 0; i < numTriangles; i++) {
                const index = i * 9; // 3 vertices per triangle, 3 components (x,y,z) per vertex
                
                // Calculate average normal for the triangle
                const nx = (normals[index] + normals[index + 3] + normals[index + 6]) / 3;
                const ny = (normals[index + 1] + normals[index + 4] + normals[index + 7]) / 3;
                const nz = (normals[index + 2] + normals[index + 5] + normals[index + 8]) / 3;
                
                // Write normal (3 floats x 4 bytes = 12 bytes)
                dataView.setFloat32(offset, nx, true);
                dataView.setFloat32(offset + 4, ny, true);
                dataView.setFloat32(offset + 8, nz, true);
                offset += 12;
                
                // Write vertices (9 floats x 4 bytes = 36 bytes)
                for (let j = 0; j < 9; j += 3) {
                    dataView.setFloat32(offset, positions[index + j], true);     // x
                    dataView.setFloat32(offset + 4, positions[index + j + 1], true); // y
                    dataView.setFloat32(offset + 8, positions[index + j + 2], true); // z
                    offset += 12;
                }
                
                // Attribute byte count (2 bytes) - unused in binary STL
                dataView.setUint16(offset, 0, true);
                offset += 2;
            }
            
            // Create a blob from the binary data
            stlContent = new Blob([buffer], { type: 'application/octet-stream' });
            return true;
            
        } catch (error) {
            console.error('Error generating STL:', error);
            return createFallbackSTL();
        }
    }
        
    // Create a fallback STL cube if generation fails
    function createFallbackSTL() {
        console.warn('Creating fallback STL cube');
        
        // Create a placeholder STL file (binary format)
        const headerSize = 80;
        const header = new Uint8Array(headerSize);
        
        // Create a simple cube STL with 12 triangles (2 per face)
        const numTriangles = 12;
        const dataSize = 50 * numTriangles;
        const buffer = new ArrayBuffer(headerSize + 4 + dataSize);
        
        const dataView = new DataView(buffer);
        
        // Fill header (80 bytes)
        for (let i = 0; i < headerSize; i++) {
            dataView.setUint8(i, header[i]);
        }
        
        // Number of triangles (4 bytes)
        dataView.setUint32(headerSize, numTriangles, true);
        
        // For the demo, we'll just create a binary blob
        stlContent = new Blob([buffer], { type: 'application/octet-stream' });
        return false;
    }
        
    // Handle download button
    downloadBtn.addEventListener('click', function() {
        if (!stlContent) return;
        
        // Create download link
        const link = document.createElement('a');
        link.href = URL.createObjectURL(stlContent);
        link.download = 'model.stl';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });
    </script>
</body>
</html>
