<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG to STL Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .drop-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin: 20px 0;
            transition: border 0.3s;
            cursor: pointer;
        }
        .drop-area.highlight {
            border-color: #4CAF50;
        }
        .file-input {
            display: none;
        }
        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        .btn:hover {
            background-color: #45a049;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .preview-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .preview-box {
            flex: 1;
            margin: 0 10px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
            height: 400px;
            overflow: hidden;
            position: relative;
        }
        .preview-box h3 {
            margin-top: 0;
            text-align: center;
        }
        #svg-preview {
            width: 100%;
            height: 340px;
            background-color: #fff;
        }
        #stl-preview {
            width: 100%;
            height: 340px;
            background-color: #fff;
        }
        .settings {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .settings-label {
            flex: 0 0 150px;
        }
        input[type="range"] {
            flex: 1;
        }
        input[type="number"] {
            width: 60px;
            margin-left: 10px;
            padding: 3px;
        }
        /* New styles for mode toggle */
        .toggle-container {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
            margin: 0 10px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #4CAF50;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(32px);
        }
        .toggle-label {
            font-weight: bold;
        }
        stl-converter-modal .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f5f5f5;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        #stl-converter-modal .modal-header h3 {
            margin: 0;
        }
    
        @media (prefers-color-scheme: dark) {
            #stl-converter-modal .modal-header {
                background-color: #2a2a2a;
                border-color: #333;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SVG to STL Converter</h1>
        
        <div id="drop-area" class="drop-area">
            <p>Drag & drop your SVG file here, or</p>
            <input type="file" id="file-input" class="file-input" accept=".svg">
            <button class="btn" onclick="document.getElementById('file-input').click()">Select File</button>
            <p style="margin-top: 15px;">Or paste SVG code:</p>
            <button class="btn" onclick="toggleSvgTextarea()">Paste SVG</button>
        </div>
        
        <div id="svg-textarea-container" style="display: none; margin: 15px 0;">
            <textarea id="svg-textarea" style="width: 100%; height: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="Paste your SVG code here..."></textarea>
            <div style="text-align: right; margin-top: 5px;">
                <button class="btn" onclick="processPastedSVG()">Process SVG</button>
            </div>
        </div>
        
        <div class="settings">
            <h3>Conversion Mode</h3>
            <div class="toggle-container">
                <span class="toggle-label">Volume Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">Line Mode</span>
            </div>
            <p id="mode-description" style="margin-top: 5px; font-size: 14px; color: #666;">
                Volume Mode: Filled areas become solid, empty areas become holes.
            </p>
            
            <h3>Extrusion Settings</h3>
            <div class="settings-row">
                <label class="settings-label" for="extrusion-height">Extrusion Height:</label>
                <input type="range" id="extrusion-height" min="0.00001" step="0.001" max="50" value="1" oninput="this.nextElementSibling.value = this.value">
                <input type="number" min="0.00001"  max="50" value="1" oninput="this.previousElementSibling.value = this.value">
            </div>
            <div class="settings-row">
                <label class="settings-label" for="base-thickness">Base Thickness:</label>
                <input type="range" id="base-thickness" min="0" max="10" value="2" oninput="this.nextElementSibling.value = this.value">
                <input type="number" min="0" max="10" value="2" oninput="this.previousElementSibling.value = this.value">
            </div>
            <div class="settings-row">
                <label class="settings-label" for="resolution" title="Higher values create more detailed models with higher polygon counts">Resolution:</label>
                <input type="range" id="resolution" min="1" max="50" value="5" oninput="this.nextElementSibling.value = this.value">
                <input type="number" min="1" max="50" value="5" oninput="this.previousElementSibling.value = this.value">
                <span style="margin-left: 10px; font-size: 12px; color: #666;">(Higher = more polygons)</span>
            </div>
        </div>
        
        <div class="btn-container" style="text-align: center;">
            <button id="convert-btn" class="btn" disabled>Convert to STL</button>
            <button id="download-btn" class="btn" disabled>Download STL</button>
        </div>
        
        <div class="preview-container">
            <div class="preview-box">
                <h3>SVG Preview</h3>
                <div id="svg-preview"></div>
            </div>
            <div class="preview-box">
                <h3>STL Preview</h3>
                <div id="stl-preview"></div>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';
        import {OrbitControls} from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/controls/OrbitControls.js';
        import * as BufferGeometryUtils from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/utils/BufferGeometryUtils.js';
    
    </script>
    
    <script>
        // DOM elements
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const convertBtn = document.getElementById('convert-btn');
        const downloadBtn = document.getElementById('download-btn');
        const svgPreview = document.getElementById('svg-preview');
        const stlPreview = document.getElementById('stl-preview');
        const modeToggle = document.getElementById('mode-toggle');
        const modeDescription = document.getElementById('mode-description');
        
        // State variables
        let svgContent = null;
        let stlContent = null;
        let svgPaths = [];
        let svgViewBox = { x: 0, y: 0, width: 100, height: 100 };
        let scene = null; // Global scene reference
        let isLineMode = false; // Default to Volume Mode
        
        // Mode toggle event listener
        modeToggle.addEventListener('change', function() {
            isLineMode = this.checked;
            if (isLineMode) {
                modeDescription.textContent = 'Line Mode: Lines are treated as boundaries, thickness is ignored.';
            } else {
                modeDescription.textContent = 'Volume Mode: Filled areas become solid, empty areas become holes.';
            }
            
            // Re-parse SVG if we have content
            if (svgContent) {
                parseSVG(svgContent);
            }
        });
        
        // SVG Textarea toggle
        function toggleSvgTextarea() {
            const container = document.getElementById('svg-textarea-container');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                document.getElementById('svg-textarea').focus();
            } else {
                container.style.display = 'none';
            }
        }
        
        // Process pasted SVG
        function processPastedSVG() {
            const textarea = document.getElementById('svg-textarea');
            const svgCode = textarea.value.trim();
            
            if (!svgCode) {
                alert('Please paste SVG code');
                return;
            }
            
            if (!svgCode.includes('<svg') || !svgCode.includes('</svg>')) {
                alert('Invalid SVG code. Make sure to include the <svg> tag.');
                return;
            }
            
            svgContent = svgCode;
            displaySVG(svgContent);
            parseSVG(svgContent);
            convertBtn.disabled = false;
            
            // Hide textarea after processing
            document.getElementById('svg-textarea-container').style.display = 'none';
        }
        
        // Handle drag and drop events
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.classList.add('highlight');
        }
        
        function unhighlight() {
            dropArea.classList.remove('highlight');
        }
        
        // Handle file drops
        dropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }
        
        fileInput.addEventListener('change', function() {
            handleFiles(this.files);
        });
        
        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'image/svg+xml') {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        svgContent = e.target.result;
                        displaySVG(svgContent);
                        parseSVG(svgContent);
                        convertBtn.disabled = false;
                    };
                    reader.readAsText(file);
                } else {
                    alert('Please upload an SVG file.');
                }
            }
        }
        
        function displaySVG(svgString) {
            svgPreview.innerHTML = svgString;
            // Make sure the SVG scales to fit the preview area
            const svgElement = svgPreview.querySelector('svg');
            if (svgElement) {
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';
            }
        }
        
        // Helper function to create path data for rounded rectangle
        function createRoundedRectPath(x, y, width, height, radius) {
            return `M${x + radius},${y}
                    L${x + width - radius},${y}
                    A${radius},${radius} 0 0 1 ${x + width},${y + radius}
                    L${x + width},${y + height - radius}
                    A${radius},${radius} 0 0 1 ${x + width - radius},${y + height}
                    L${x + radius},${y + height}
                    A${radius},${radius} 0 0 1 ${x},${y + height - radius}
                    L${x},${y + radius}
                    A${radius},${radius} 0 0 1 ${x + radius},${y}
                    Z`;
        }

        // Create points to approximate an arc
        function approximateArc(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2) {
            // Convert angle from degrees to radians
            const angleRad = angle * Math.PI / 180;
            
            // Create a proper approximation with multiple points
            const numSegments = 8; // Increase for smoother arcs
            const points = [];
            
            // Find center of ellipse (simplified, assumes unrotated ellipse)
            // Convert from endpoint to center parameterization
            const dx = (x2 - x1) / 2;
            const dy = (y2 - y1) / 2;
            const x1p = 0;
            const y1p = 0;
            
            // Adjust for different sweep and large arc flags
            let start, end;
            if ((!largeArcFlag && !sweepFlag) || (largeArcFlag && sweepFlag)) {
                start = 0;
                end = Math.PI / 2;
            } else {
                start = Math.PI / 2;
                end = Math.PI;
            }
            
            // Generate points along the arc
            for (let i = 0; i <= numSegments; i++) {
                const t = start + (i / numSegments) * (end - start);
                const pointX = x1 + rx * Math.cos(t);
                const pointY = y1 + ry * Math.sin(t);
                points.push({ x: pointX, y: pointY });
            }
            
            // Always include the end point
            if (points.length === 0 || 
                (points[points.length-1].x !== x2 || points[points.length-1].y !== y2)) {
                points.push({ x: x2, y: y2 });
            }
            
            return points;
        }

        function updateResolutionSetting() {
            // Count the number of paths and the average number of points
            let totalPoints = 0;
            svgPaths.forEach(path => {
                const commands = parseSVGPath(path.pathData);
                totalPoints += commands.length;
            });
            
            // Average points per path
            const avgPoints = totalPoints / svgPaths.length || 0;
            // Estimate complexity and set reasonable default
            const complexity = Math.min(50, Math.max(5, Math.ceil(avgPoints / 4)));
            
            const resolutionSlider = document.getElementById('resolution');
            const resolutionValue = document.getElementById('resolution').nextElementSibling;
            
            resolutionSlider.value = complexity;
            resolutionValue.value = complexity;
        }

        /**
     * Calculates the angle between two 2D vectors.
     * The angle is measured from vector (ux, uy) to vector (vx, vy) in radians.
     * The result is between -PI and PI.
     * @param {number} ux X-component of the first vector
     * @param {number} uy Y-component of the first vector
     * @param {number} vx X-component of the second vector
     * @param {number} vy Y-component of the second vector
     * @returns {number} Angle in radians
     */
    function angleBetween(ux, uy, vx, vy) {
    // Handle zero vectors
    if ((ux === 0 && uy === 0) || (vx === 0 && vy === 0)) {
        return 0;
    }
    
    const dot = ux * vx + uy * vy;
    const lenU = Math.sqrt(ux * ux + uy * uy);
    const lenV = Math.sqrt(vx * vx + vy * vy);
    
    // Clamp the cosine value to avoid floating point errors
    let cosTheta = Math.max(-1.0, Math.min(1.0, dot / (lenU * lenV)));
    let angle = Math.acos(cosTheta);
    
    // Determine sign using cross product
    const cross = ux * vy - uy * vx;
    if (cross < 0) {
        angle = -angle;
    }
    
    return angle;
}
                
        function createShapeFromPathData(shape, pathData, scale) {
    // Parse SVG path data and create a Three.js shape
    const commands = parseSVGPath(pathData);
    let firstCommand = true;
    let lastControlPoint = null;
    
    for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i];
        const type = cmd.type;
        const args = cmd.args.map(arg => arg * scale);
        
        try {
            switch(type) {
                case 'M': // Move to (absolute)
                    shape.moveTo(args[0], -args[1]); // Note Y-axis flip for Three.js
                    break;
                case 'm': // Move to (relative)
                    if (firstCommand) {
                        shape.moveTo(args[0], -args[1]);
                    } else {
                        const currentPoint = shape.currentPoint;
                        shape.moveTo(currentPoint.x + args[0], currentPoint.y - args[1]);
                    }
                    break;
                case 'L': // Line to (absolute)
                    shape.lineTo(args[0], -args[1]);
                    break;
                case 'l': // Line to (relative)
                    const currentPoint = shape.currentPoint;
                    shape.lineTo(currentPoint.x + args[0], currentPoint.y - args[1]);
                    break;
                case 'H': // Horizontal line (absolute)
                    shape.lineTo(args[0], shape.currentPoint.y);
                    break;
                case 'h': // Horizontal line (relative)
                    shape.lineTo(shape.currentPoint.x + args[0], shape.currentPoint.y);
                    break;
                case 'V': // Vertical line (absolute)
                    shape.lineTo(shape.currentPoint.x, -args[0]);
                    break;
                case 'v': // Vertical line (relative)
                    shape.lineTo(shape.currentPoint.x, shape.currentPoint.y - args[1]);
                    break;
                case 'C': // Cubic curve (absolute)
                    shape.bezierCurveTo(
                        args[0], -args[1],
                        args[2], -args[3],
                        args[4], -args[5]
                    );
                    lastControlPoint = { x: args[2], y: -args[3] };
                    break;
                case 'c': // Cubic curve (relative)
                    const cp = shape.currentPoint;
                    shape.bezierCurveTo(
                        cp.x + args[0], cp.y - args[1],
                        cp.x + args[2], cp.y - args[3],
                        cp.x + args[4], cp.y - args[5]
                    );
                    lastControlPoint = { 
                        x: cp.x + args[2], 
                        y: cp.y - args[3] 
                    };
                    break;
                case 'S': // Smooth cubic curve (absolute)
                    const s1 = shape.currentPoint;
                    let sx1, sy1;
                    
                    if (lastControlPoint && (commands[i-1].type === 'C' || commands[i-1].type === 'c' || 
                                            commands[i-1].type === 'S' || commands[i-1].type === 's')) {
                        // Reflect previous control point
                        sx1 = 2 * s1.x - lastControlPoint.x;
                        sy1 = 2 * s1.y - lastControlPoint.y;
                    } else {
                        // No previous control point, use current point
                        sx1 = s1.x;
                        sy1 = s1.y;
                    }
                    
                    shape.bezierCurveTo(
                        sx1, sy1,
                        args[0], -args[1],
                        args[2], -args[3]
                    );
                    lastControlPoint = { x: args[0], y: -args[1] };
                    break;
                case 's': // Smooth cubic curve (relative)
                    const s2 = shape.currentPoint;
                    let sx2, sy2;
                    
                    if (lastControlPoint && (commands[i-1].type === 'C' || commands[i-1].type === 'c' || 
                                            commands[i-1].type === 'S' || commands[i-1].type === 's')) {
                        // Reflect previous control point
                        sx2 = 2 * s2.x - lastControlPoint.x;
                        sy2 = 2 * s2.y - lastControlPoint.y;
                    } else {
                        // No previous control point, use current point
                        sx2 = s2.x;
                        sy2 = s2.y;
                    }
                    
                    shape.bezierCurveTo(
                        sx2, sy2,
                        s2.x + args[0], s2.y - args[1],
                        s2.x + args[2], s2.y - args[3]
                    );
                    lastControlPoint = { 
                        x: s2.x + args[0], 
                        y: s2.y - args[1] 
                    };
                    break;
                case 'Q': // Quadratic curve (absolute)
                    shape.quadraticCurveTo(
                        args[0], -args[1],
                        args[2], -args[3]
                    );
                    lastControlPoint = { x: args[0], y: -args[1] };
                    break;
                case 'q': // Quadratic curve (relative)
                    const qp = shape.currentPoint;
                    shape.quadraticCurveTo(
                        qp.x + args[0], qp.y - args[1],
                        qp.x + args[2], qp.y - args[3]
                    );
                    lastControlPoint = { 
                        x: qp.x + args[0], 
                        y: qp.y - args[1] 
                    };
                    break;
                case 'T': // Smooth quadratic curve (absolute)
                    const t1 = shape.currentPoint;
                    let tx1, ty1;
                    
                    if (lastControlPoint && (commands[i-1].type === 'Q' || commands[i-1].type === 'q' || 
                                            commands[i-1].type === 'T' || commands[i-1].type === 't')) {
                        // Reflect previous control point
                        tx1 = 2 * t1.x - lastControlPoint.x;
                        ty1 = 2 * t1.y - lastControlPoint.y;
                    } else {
                        // No previous control point, use current point
                        tx1 = t1.x;
                        ty1 = t1.y;
                    }
                    
                    shape.quadraticCurveTo(
                        tx1, ty1,
                        args[0], -args[1]
                    );
                    lastControlPoint = { x: tx1, y: ty1 };
                    break;
                case 't': // Smooth quadratic curve (relative)
                    const t2 = shape.currentPoint;
                    let tx2, ty2;
                    
                    if (lastControlPoint && (commands[i-1].type === 'Q' || commands[i-1].type === 'q' || 
                                            commands[i-1].type === 'T' || commands[i-1].type === 't')) {
                        // Reflect previous control point
                        tx2 = 2 * t2.x - lastControlPoint.x;
                        ty2 = 2 * t2.y - lastControlPoint.y;
                    } else {
                        // No previous control point, use current point
                        tx2 = t2.x;
                        ty2 = t2.y;
                    }
                    
                    shape.quadraticCurveTo(
                        tx2, ty2,
                        t2.x + args[0], t2.y - args[1]
                    );
                    lastControlPoint = { x: tx2, y: ty2 };
                    break;
                case 'A': // Arc (absolute)
                    // Get current point
                    const arcStart = shape.currentPoint;
                    const startX = arcStart.x;
                    const startY = arcStart.y;
                    
                    // Arc parameters
                    const rx = Math.abs(args[0]);
                    const ry = Math.abs(args[1]);
                    const xAxisRotation = args[2] * Math.PI / 180;
                    const largeArcFlag = args[3] !== 0;
                    const sweepFlag = args[4] !== 0;
                    const endX = args[5];
                    const endY = -args[6];
                    
                    // Skip zero-radius arcs or when start and end are identical
                    if ((rx === 0 || ry === 0) || 
                        (Math.abs(startX - endX) < 1e-6 && Math.abs(startY - endY) < 1e-6)) {
                        shape.lineTo(endX, endY);
                        break;
                    }
                    
                    // Use Three.js's absellipse for the arc
                    try {
                        // Convert from endpoint to center parameterization
                        const phi = xAxisRotation;
                        const sinphi = Math.sin(phi);
                        const cosphi = Math.cos(phi);
                        
                        // Step 1: Compute transformed start point
                        const x1p = cosphi * (startX - endX) / 2 + sinphi * (startY - endY) / 2;
                        const y1p = -sinphi * (startX - endX) / 2 + cosphi * (startY - endY) / 2;
                        
                        // Step 2: Ensure radii are large enough
                        let rxsq = rx * rx;
                        let rysq = ry * ry;
                        const x1psq = x1p * x1p;
                        const y1psq = y1p * y1p;
                        
                        const radiiCheck = x1psq / rxsq + y1psq / rysq;
                        if (radiiCheck > 1) {
                            const radiiScale = Math.sqrt(radiiCheck);
                            rx *= radiiScale;
                            ry *= radiiScale;
                            rxsq = rx * rx;
                            rysq = ry * ry;
                        }
                        
                        // Step 3: Compute center
                        const sign = (largeArcFlag !== sweepFlag) ? 1 : -1;
                        const term = rxsq * y1psq + rysq * x1psq;
                        const sq = Math.sqrt(Math.max(0, (rxsq * rysq - term) / term));
                        const cxp = sign * sq * rx * y1p / ry;
                        const cyp = sign * -sq * ry * x1p / rx;
                        
                        // Step 4: Transform back to original coordinate system
                        const cx = cosphi * cxp - sinphi * cyp + (startX + endX) / 2;
                        const cy = sinphi * cxp + cosphi * cyp + (startY + endY) / 2;
                        
                        // Step 5: Compute angles
                        const ux = (x1p - cxp) / rx;
                        const uy = (y1p - cyp) / ry;
                        const vx = (-x1p - cxp) / rx;
                        const vy = (-y1p - cyp) / ry;
                        
                        // Compute starting angle
                        let startAngle = angleBetween(1, 0, ux, uy);
                        
                        // Compute angle delta
                        let deltaAngle = angleBetween(ux, uy, vx, vy);
                        
                        // Adjust delta angle based on sweep flag
                        if (!sweepFlag && deltaAngle > 0) {
                            deltaAngle -= 2 * Math.PI;
                        } else if (sweepFlag && deltaAngle < 0) {
                            deltaAngle += 2 * Math.PI;
                        }
                        
                        // Use absellipse to draw the arc
                        shape.absellipse(
                            cx, cy, 
                            rx, ry, 
                            startAngle, startAngle + deltaAngle, 
                            !sweepFlag, 
                            xAxisRotation
                        );
                    } catch (err) {
                        console.error('Arc error:', err);
                        // Fallback to line if arc fails
                        shape.lineTo(endX, endY);
                    }
                    break;
                case 'a': // Arc (relative)
                    // Get current point
                    const relArcStart = shape.currentPoint;
                    
                    // Convert relative endpoint to absolute
                    const relEndX = relArcStart.x + args[5];
                    const relEndY = relArcStart.y - args[6];
                    
                    // Prepare absolute arc parameters
                    const absArgs = [
                        args[0], args[1], args[2],
                        args[3], args[4],
                        relEndX, -relEndY / scale  // Convert back to SVG coordinates
                    ];
                    
                    // Reuse absolute arc logic
                    try {
                        // Similar to 'A' case but with relative endpoint
                        const phi = args[2] * Math.PI / 180;
                        const rx = Math.abs(args[0]);
                        const ry = Math.abs(args[1]);
                        const largeArcFlag = args[3] !== 0;
                        const sweepFlag = args[4] !== 0;
                        
                        // Skip zero-radius arcs
                        if (rx === 0 || ry === 0) {
                            shape.lineTo(relEndX, relEndY);
                            break;
                        }
                        
                        // Convert from endpoint to center parameterization
                        const startX = relArcStart.x;
                        const startY = relArcStart.y;
                        const endX = relEndX;
                        const endY = relEndY;
                        
                        const sinphi = Math.sin(phi);
                        const cosphi = Math.cos(phi);
                        
                        // Step 1: Compute transformed start point
                        const x1p = cosphi * (startX - endX) / 2 + sinphi * (startY - endY) / 2;
                        const y1p = -sinphi * (startX - endX) / 2 + cosphi * (startY - endY) / 2;
                        
                        // Ensure radii are large enough
                        let rxsq = rx * rx;
                        let rysq = ry * ry;
                        const x1psq = x1p * x1p;
                        const y1psq = y1p * y1p;
                        
                        const radiiCheck = x1psq / rxsq + y1psq / rysq;
                        if (radiiCheck > 1) {
                            const radiiScale = Math.sqrt(radiiCheck);
                            rx *= radiiScale;
                            ry *= radiiScale;
                            rxsq = rx * rx;
                            rysq = ry * ry;
                        }
                        
                        // Step 3: Compute center
                        const sign = (largeArcFlag !== sweepFlag) ? 1 : -1;
                        const term = rxsq * y1psq + rysq * x1psq;
                        const sq = Math.sqrt(Math.max(0, (rxsq * rysq - term) / term));
                        const cxp = sign * sq * rx * y1p / ry;
                        const cyp = sign * -sq * ry * x1p / rx;
                        
                        // Step 4: Transform back to original coordinate system
                        const cx = cosphi * cxp - sinphi * cyp + (startX + endX) / 2;
                        const cy = sinphi * cxp + cosphi * cyp + (startY + endY) / 2;
                        
                        // Step 5: Compute angles
                        const ux = (x1p - cxp) / rx;
                        const uy = (y1p - cyp) / ry;
                        const vx = (-x1p - cxp) / rx;
                        const vy = (-y1p - cyp) / ry;
                        
                        // Compute starting angle
                        let startAngle = angleBetween(1, 0, ux, uy);
                        
                        // Compute angle delta
                        let deltaAngle = angleBetween(ux, uy, vx, vy);
                        
                        // Adjust delta angle based on sweep flag
                        if (!sweepFlag && deltaAngle > 0) {
                            deltaAngle -= 2 * Math.PI;
                        } else if (sweepFlag && deltaAngle < 0) {
                            deltaAngle += 2 * Math.PI;
                        }
                        
                        // Use absellipse to draw the arc
                        shape.absellipse(
                            cx, cy, 
                            rx, ry, 
                            startAngle, startAngle + deltaAngle, 
                            !sweepFlag, 
                            phi
                        );
                    } catch (err) {
                        console.error('Relative Arc error:', err);
                        shape.lineTo(relEndX, relEndY);
                    }
                    break;
                case 'Z':
                case 'z':
                    shape.closePath();
                    break;
                default:
                    console.warn('Unsupported SVG command:', type);
            }
        } catch (e) {
            console.error(`Error processing command ${type}:`, e);
            if (i < commands.length - 1) {
                // Try to recover by continuing with next command
                continue;
            } else if (type === 'Z' || type === 'z') {
                // Try to close the path anyway
                try {
                    shape.closePath();
                } catch (closeErr) {
                    console.error('Failed to close path:', closeErr);
                }
            }
        }
        
        firstCommand = false;
    }
}

        function updateExtrusionSettings(viewBox) {
    if (!viewBox) return;
    
    // Calculate appropriate extrusion height range based on SVG dimensions
    const maxDimension = Math.max(viewBox.width, viewBox.height);
    const defaultHeight = Math.max(0.0001, maxDimension * 0.00025); // 5% of max dimension
    
    // Update extrusion height slider
    const extrusionHeightSlider = document.getElementById('extrusion-height');
    const extrusionHeightValue = document.getElementById('extrusion-height').nextElementSibling;
    
    //extrusionHeightSlider.min = "0.1";
    extrusionHeightSlider.max = (maxDimension * 0.005); // 50% of max dimension
    extrusionHeightSlider.value = defaultHeight;
    extrusionHeightValue.value = defaultHeight;
    
    // Also update base thickness to be proportional
    const baseThicknessSlider = document.getElementById('base-thickness');
    const baseThicknessValue = document.getElementById('base-thickness').nextElementSibling;
    
    const defaultBase = Math.max(0.5, (maxDimension * 0.01)); // 1% of max dimension
    baseThicknessSlider.min = "0";
    baseThicknessSlider.step = Math.min(1,maxDimension/1000);
    baseThicknessSlider.max = (maxDimension * 0.1); // 10% of max dimension
    baseThicknessSlider.value = defaultBase;
    baseThicknessValue.value = defaultBase;
}
        
      function parseSVG(svgString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, 'image/svg+xml');
        const svg = doc.querySelector('svg');
        
        // Extract viewBox
        if (svg.getAttribute('viewBox')) {
            const viewBoxValues = svg.getAttribute('viewBox').split(' ');
            svgViewBox = {
                x: parseFloat(viewBoxValues[0]),
                y: parseFloat(viewBoxValues[1]),
                width: parseFloat(viewBoxValues[2]),
                height: parseFloat(viewBoxValues[3])
            };
        } else if (svg.getAttribute('width') && svg.getAttribute('height')) {
            svgViewBox = {
                x: 0,
                y: 0,
                width: parseFloat(svg.getAttribute('width')),
                height: parseFloat(svg.getAttribute('height'))
            };
        }

        updateExtrusionSettings(svgViewBox);
        
        // Structure to hold paths and their types (outer contours vs holes)
        svgPaths = [];
        
        // Extract all elements that can define shapes
        const pathElements = svg.querySelectorAll('path');
        const rectElements = svg.querySelectorAll('rect');
        const circleElements = svg.querySelectorAll('circle');
        const lineElements = svg.querySelectorAll('line');
        const polylineElements = svg.querySelectorAll('polyline');
        const polygonElements = svg.querySelectorAll('polygon');
        const onlyHasRects = svg.querySelectorAll('*').length === 1 && 
                    svg.querySelectorAll('rect[rx],rect[ry]').length === 1;

        // Process paths
        pathElements.forEach(path => {
            let isHole = isLineMode ? false : determineIfHole(path);
            svgPaths.push({
                pathData: path.getAttribute('d'),
                isHole: isHole,
                strokeWidth: parseFloat(path.getAttribute('stroke-width') || 1),
                element: path
            });
        });
        
        // Process rectangles
        rectElements.forEach(rect => {
            const x = parseFloat(rect.getAttribute('x') || 0);
            const y = parseFloat(rect.getAttribute('y') || 0);
            const width = parseFloat(rect.getAttribute('width'));
            const height = parseFloat(rect.getAttribute('height'));
            const rx = parseFloat(rect.getAttribute('rx') || 0);
            const ry = parseFloat(rect.getAttribute('ry') || 0);
            
            let pathData;
            if (rx || ry) {
                // Handle rounded rectangles
                const r = rx || ry;
                pathData = createRoundedRectPath(x, y, width, height, r);
            } else {
                // Simple rectangle
                pathData = `M${x},${y} h${width} v${height} h-${width} Z`;
            }
            
            let isHole = isLineMode ? false : determineIfHole(rect);
            svgPaths.push({
                pathData: pathData,
                isHole: isHole,
                strokeWidth: parseFloat(rect.getAttribute('stroke-width') || 1),
                element: rect
            });
        });
        
        // Process circles
        circleElements.forEach(circle => {
            const cx = parseFloat(circle.getAttribute('cx'));
            const cy = parseFloat(circle.getAttribute('cy'));
            const r = parseFloat(circle.getAttribute('r'));
            
            // Approximate circle with a path
            const pathData = `M${cx+r},${cy} 
                            A${r},${r} 0 0 1 ${cx},${cy-r} 
                            A${r},${r} 0 0 1 ${cx-r},${cy} 
                            A${r},${r} 0 0 1 ${cx},${cy+r} 
                            A${r},${r} 0 0 1 ${cx+r},${cy} Z`;
            
            let isHole = isLineMode ? false : determineIfHole(circle);
            svgPaths.push({
                pathData: pathData,
                isHole: isHole,
                strokeWidth: parseFloat(circle.getAttribute('stroke-width') || 1),
                element: circle
            });
        });
        
        // In Line Mode, also process lines and convert to paths with thickness
        if (isLineMode) {
            // Process lines
            lineElements.forEach(line => {
                const x1 = parseFloat(line.getAttribute('x1'));
                const y1 = parseFloat(line.getAttribute('y1'));
                const x2 = parseFloat(line.getAttribute('x2'));
                const y2 = parseFloat(line.getAttribute('y2'));
                const strokeWidth = parseFloat(line.getAttribute('stroke-width') || 1);
                
                // Create a path from the line with thickness
                const pathData = createLinePathWithThickness(x1, y1, x2, y2, strokeWidth);
                
                svgPaths.push({
                    pathData: pathData,
                    isHole: false,
                    strokeWidth: strokeWidth,
                    element: line
                });
            });
            
            // Process polylines
            polylineElements.forEach(polyline => {
                const points = polyline.getAttribute('points').trim().split(/\s+|,/);
                const strokeWidth = parseFloat(polyline.getAttribute('stroke-width') || 1);
                
                // Create a path from the polyline with thickness
                let pathData = '';
                for (let i = 0; i < points.length - 2; i += 2) {
                    const x1 = parseFloat(points[i]);
                    const y1 = parseFloat(points[i+1]);
                    const x2 = parseFloat(points[i+2]);
                    const y2 = parseFloat(points[i+3]);
                    
                    if (i === 0) {
                        // Starting segment
                        pathData = createLinePathWithThickness(x1, y1, x2, y2, strokeWidth);
                    } else {
                        // Continuing segments, append path
                        pathData += createLinePathWithThickness(x1, y1, x2, y2, strokeWidth, true);
                    }
                }
                
                svgPaths.push({
                    pathData: pathData,
                    isHole: false,
                    strokeWidth: strokeWidth,
                    element: polyline
                });
            });
            
            // Process polygons
            polygonElements.forEach(polygon => {
                const points = polygon.getAttribute('points').trim().split(/\s+|,/);
                const fillColor = polygon.getAttribute('fill');
                let isHole = false;
                
                if (fillColor === 'none' || fillColor === '#fff' || fillColor === '#ffffff' || fillColor === 'white') {
                    isHole = true;
                }
                
                // Create a path from the polygon
                let pathData = `M${points[0]},${points[1]}`;
                for (let i = 2; i < points.length; i += 2) {
                    pathData += ` L${points[i]},${points[i+1]}`;
                }
                pathData += ' Z';
                
                svgPaths.push({
                    pathData: pathData,
                    isHole: isHole,
                    strokeWidth: parseFloat(polygon.getAttribute('stroke-width') || 1),
                    element: polygon
                });
            });
        }

        updateResolutionSetting();
        
        console.log('Parsed SVG with', svgPaths.length, 'paths/shapes');
        console.log('Holes:', svgPaths.filter(p => p.isHole).length);
        console.log('Outer contours:', svgPaths.filter(p => !p.isHole).length);
        console.log('Mode:', isLineMode ? 'Line Mode' : 'Volume Mode');
    }
    
    // Helper function to create a path for a line with thickness
    function createLinePathWithThickness(x1, y1, x2, y2, thickness, isSegment = false) {
        // Calculate perpendicular direction for thickness
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate offset perpendicular to the line direction
        const halfThickness = thickness / 2;
        const offsetX = (dy / length) * halfThickness;
        const offsetY = -(dx / length) * halfThickness;
        
        // Calculate the four corners of the thick line
        const x1Left = x1 - offsetX;
        const y1Left = y1 - offsetY;
        const x1Right = x1 + offsetX;
        const y1Right = y1 + offsetY;
        const x2Left = x2 - offsetX;
        const y2Left = y2 - offsetY;
        const x2Right = x2 + offsetX;
        const y2Right = y2 + offsetY;
        
        if (isSegment) {
            // For continuing segments, just return the right side path
            return `L${x2Left},${y2Left} L${x2Right},${y2Right}`;
        } else {
            // For a complete path, create a closed rectangular path
            return `M${x1Left},${y1Left} L${x2Left},${y2Left} L${x2Right},${y2Right} L${x1Right},${y1Right} Z`;
        }
    }
      
    // Parse SVG path data string into commands
    function parseSVGPath(pathData) {
        const commands = [];
        const pathParser = /([MmLlHhVvCcSsQqTtAaZz])([^MmLlHhVvCcSsQqTtAaZz]*)/g;
        let match;
        
        while ((match = pathParser.exec(pathData)) !== null) {
            const type = match[1];
            const argsStr = match[2].trim();
            let args = [];
            
            if (argsStr) {
                // Handle both comma and space separated values
                args = argsStr.replace(/,/g, ' ')
                            .split(/\s+/)
                            .map(parseFloat)
                            .filter(arg => !isNaN(arg));
            }
            
            commands.push({ type, args });
        }
        
        return commands;
    }
      
    function determineIfHole(element) {
        // In Line Mode, we don't consider anything as a hole inherently
        if (isLineMode) {
            return false;
        }
        
        // Check if the element has explicit hole markers
        if (element.getAttribute('data-hole') === 'true') {
            return true;
        }
        
        // Check fill attribute - no fill or white fill often indicates a hole
        const fill = element.getAttribute('fill');
        if (fill === 'none' || fill === '#fff' || fill === '#ffffff' || fill === 'white') {
            return true;
        }
        
        // Check for path direction - clockwise paths are typically outer contours,
        // counter-clockwise paths are typically holes in SVG
        if (element.tagName.toLowerCase() === 'path') {
            const pathData = element.getAttribute('d');
            if (pathData && isCounterClockwise(pathData)) {
                return true;
            }
        }
        
        // For small circles with stroke, assume they're mounting holes
        if (element.tagName.toLowerCase() === 'circle') {
            const r = parseFloat(element.getAttribute('r'));
            if (r < 10 && element.getAttribute('stroke')) {
                return true;
            }
        }
        
        // Default to not being a hole
        return false;
    }
      
    // Simplified check for counter-clockwise paths (for holes)
    function isCounterClockwise(pathData) {
        // This is a simplification - for a proper implementation,
        // calculate the signed area of the polygon
        // Counter-clockwise paths have negative signed area
        
        // For now, return false to treat paths as outer contours by default
        return false;
    }
        
    // Convert SVG to STL
    convertBtn.addEventListener('click', convertToSTL);
        
    // Function to detect if one path is inside another
    function isPathInsideAnother(innerPath, outerPath, scale) {
        // Convert paths to points for checking containment
        const innerShape = new THREE.Shape();
        const outerShape = new THREE.Shape();
        
        try {
            createShapeFromPathData(innerShape, innerPath.pathData, scale);
            createShapeFromPathData(outerShape, outerPath.pathData, scale);
            
            // Get a point from the inner shape (using first point)
            const innerPoints = innerShape.getPoints(8);
            if (innerPoints.length === 0) return false;
            
            const testPoint = innerPoints[0];
            
            // Check if this point is inside the outer shape
            return isPointInShape(testPoint, outerShape);
        } catch (e) {
            console.error('Error in path containment check:', e);
            return false;
        }
    }
    
    // Test if a point is inside a shape using ray casting algorithm
    function isPointInShape(point, shape) {
        const shapePoints = shape.getPoints(32);
        let inside = false;
        
        // Ray casting algorithm
        for (let i = 0, j = shapePoints.length - 1; i < shapePoints.length; j = i++) {
            const xi = shapePoints[i].x, yi = shapePoints[i].y;
            const xj = shapePoints[j].x, yj = shapePoints[j].y;
            
            const intersect = ((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                
            if (intersect) inside = !inside;
        }
        
        return inside;
    }
    
    async function convertToSTL() {
        if (!svgContent) return;
        
        try {
            // Make sure BufferGeometryUtils is loaded
            await loadBufferGeometryUtils();
            
            const extrusionHeight = parseFloat(document.getElementById('extrusion-height').value);
            const baseThickness = parseFloat(document.getElementById('base-thickness').value);
            const resolution = parseFloat(document.getElementById('resolution').value);
            
            // Initialize Three.js scene
            scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 2000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(stlPreview.clientWidth, stlPreview.clientHeight);
            renderer.setClearColor(0xf0f0f0);
            
            // Clear previous preview
            stlPreview.innerHTML = '';
            stlPreview.appendChild(renderer.domElement);
            
            // Scale factor to fit the SVG to the preview
            const scale = 0.5 / Math.max(svgViewBox.width, svgViewBox.height);
            
            // Process all paths based on the current mode
            let shapes = [];
            
            if (isLineMode) {
                // Line mode processing...
                // (existing code)
            } else {
                // Volume mode processing
                const outerContours = svgPaths.filter(path => !path.isHole);
                
                if (outerContours.length > 0) {
                    // Create shapes from all outer contours
                    outerContours.forEach(contour => {
                        const shape = new THREE.Shape();
                        try {
                            createShapeFromPathData(shape, contour.pathData, scale);
                            
                            // Find holes that belong to this contour
                            const holes = svgPaths.filter(path => path.isHole).map(holePath => {
                                const hole = new THREE.Shape();
                                createShapeFromPathData(hole, holePath.pathData, scale);
                                return hole;
                            });
                            
                            // Add holes to the shape
                            shape.holes = holes;
                            shapes.push(shape);
                        } catch (e) {
                            console.error('Error creating shape:', e);
                        }
                    });
                }
            }
            
            // If no valid shapes were created, use a fallback
            if (shapes.length === 0) {
                console.warn('No valid shapes created, using fallback');
                const fallbackShape = new THREE.Shape();
                createFallbackShape(fallbackShape);
                shapes.push(fallbackShape);
            }
            
            // Create a group to hold all the extruded meshes
            const group = new THREE.Group();
            
            // Extrusion settings for solid model
            const extrudeSettings = {
                steps: 1,
                depth: extrusionHeight,
                bevelEnabled: false,
                curveSegments: resolution // Use resolution parameter for curve segments
            };
            
            // Create extruded geometries for all shapes
            shapes.forEach(shape => {
                try {
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x2194ce,
                        side: THREE.DoubleSide
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    group.add(mesh);
                } catch (e) {
                    console.error('Error extruding shape:', e);
                }
            });
            
            scene.add(group);
            
            // Center the model
            const box = new THREE.Box3().setFromObject(group);
            const center = box.getCenter(new THREE.Vector3());
            group.position.set(-center.x, -center.y, -extrusionHeight/2);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-1, -1, 1);
            scene.add(directionalLight2);
            
            // Position camera to better frame the model
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            
            // Add some margin
            cameraZ *= 1.5;
            
            camera.position.z = cameraZ;
            
            // Set up orbit controls for better preview interaction
            setupOrbitControls(camera, renderer);
            
            // Enable download button
            downloadBtn.disabled = false;
            
            // Generate binary STL data
            generateSTLData(group);
        } catch(e){
            console.error(e);
        }
    }
        
    // Helper to set up orbit controls
    function setupOrbitControls(camera, renderer) {
        // Clean up previous animation
        if (window.animationLoops) {
            window.animationLoops.forEach(id => cancelAnimationFrame(id));
            window.animationLoops = [];
        } else {
            window.animationLoops = [];
        }
        
        let animationFrameId;
        
        if (typeof THREE.OrbitControls !== 'undefined') {
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            controls.zoomSpeed = 1.2;
            controls.enablePan = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.minDistance = 1;
            controls.maxDistance = 1000;
            
            // Add instruction div if it doesn't exist
            let instructionDiv = stlPreview.querySelector('.controls-info');
            if (!instructionDiv) {
                instructionDiv = document.createElement('div');
                instructionDiv.className = 'controls-info';
                instructionDiv.style.position = 'absolute';
                instructionDiv.style.bottom = '10px';
                instructionDiv.style.left = '50%';
                instructionDiv.style.transform = 'translateX(-50%)';
                instructionDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
                instructionDiv.style.color = 'white';
                instructionDiv.style.padding = '5px 10px';
                instructionDiv.style.borderRadius = '4px';
                instructionDiv.style.fontSize = '12px';
                instructionDiv.style.pointerEvents = 'none';
                instructionDiv.textContent = 'Left click: Rotate | Right click: Pan | Scroll: Zoom';
                stlPreview.appendChild(instructionDiv);
            }
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                window.animationLoops.push(animationFrameId);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        } else {
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                window.animationLoops.push(animationFrameId);
                scene.rotation.x += 0.005;
                scene.rotation.y += 0.005;
                renderer.render(scene, camera);
            }
            animate();
        }
        
        // Clean up on window unload
        window.addEventListener('unload', () => {
            if (window.animationLoops) {
                window.animationLoops.forEach(id => cancelAnimationFrame(id));
            }
        });
    }
        
    // Create a simple fallback shape if parsing fails
    function createFallbackShape(shape) {
        shape.moveTo(-30, -20);
        shape.lineTo(30, -20);
        shape.lineTo(30, 20);
        shape.lineTo(-30, 20);
        shape.lineTo(-30, -20);
    }
    
    function generateSTLData(group) {
    try {
        // Combine all geometries in the group
        const geometries = [];
        group.traverse(child => {
            if (child instanceof THREE.Mesh) {
                geometries.push(child.geometry);
            }
        });
        
        if (geometries.length === 0) {
            console.error('No geometries found in group');
            return createFallbackSTL();
        }
        
        // Merge geometries if multiple exist
        let mergedGeometry;
        if (geometries.length > 1 && THREE.BufferGeometryUtils) {
            mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
        } else {
            mergedGeometry = geometries[0];
        }
        
        if (!mergedGeometry) {
            console.error('No geometry provided for STL generation');
            return createFallbackSTL();
        }
        
        // Make sure the geometry is a BufferGeometry for STL export
        if (!(mergedGeometry instanceof THREE.BufferGeometry)) {
            mergedGeometry = new THREE.BufferGeometry().fromGeometry(mergedGeometry);
        }
        
        // Get position attribute from geometry
        const positionAttribute = mergedGeometry.getAttribute('position');
        if (!positionAttribute) {
            console.error('Geometry has no position attribute');
            return createFallbackSTL();
        }
        
        // Get normal attribute or compute it if not present
        let normalAttribute = mergedGeometry.getAttribute('normal');
        if (!normalAttribute) {
            mergedGeometry.computeVertexNormals();
            normalAttribute = mergedGeometry.getAttribute('normal');
        }
        
        // Count triangles
        const numTriangles = positionAttribute.count / 3;
        if (numTriangles <= 0) {
            console.error('No triangles in geometry');
            return createFallbackSTL();
        }
        
        console.log(`Generating STL with ${numTriangles} triangles`);
        
        // Create STL binary file
        const headerSize = 80;
        const header = new Uint8Array(headerSize);
        
        // Calculate the size of the file
        // Header (80 bytes) + Triangle count (4 bytes) + Triangles (50 bytes each)
        const dataSize = 50 * numTriangles;
        const buffer = new ArrayBuffer(headerSize + 4 + dataSize);
        const dataView = new DataView(buffer);
        
        // Fill header (80 bytes)
        const encoder = new TextEncoder();
        const headerText = "SVG to STL conversion by SVG to STL Converter";
        const headerBytes = encoder.encode(headerText);
        for (let i = 0; i < Math.min(headerBytes.length, headerSize); i++) {
            dataView.setUint8(i, headerBytes[i]);
        }
        
        // Write the number of triangles (4 bytes, little-endian)
        dataView.setUint32(headerSize, numTriangles, true);
        
        // Offset for writing triangle data (after header and triangle count)
        let offset = headerSize + 4;
        
        // Position and normal arrays
        const positions = positionAttribute.array;
        const normals = normalAttribute.array;
        
        // For each triangle
        for (let i = 0; i < numTriangles; i++) {
            const index = i * 9; // 3 vertices per triangle, 3 components (x,y,z) per vertex
            
            // Calculate average normal for the triangle
            const nx = (normals[index] + normals[index + 3] + normals[index + 6]) / 3;
            const ny = (normals[index + 1] + normals[index + 4] + normals[index + 7]) / 3;
            const nz = (normals[index + 2] + normals[index + 5] + normals[index + 8]) / 3;
            
            // Write normal (3 floats x 4 bytes = 12 bytes)
            dataView.setFloat32(offset, nx, true);
            dataView.setFloat32(offset + 4, ny, true);
            dataView.setFloat32(offset + 8, nz, true);
            offset += 12;
            
            // Write vertices (9 floats x 4 bytes = 36 bytes)
            for (let j = 0; j < 9; j += 3) {
                dataView.setFloat32(offset, positions[index + j], true);     // x
                dataView.setFloat32(offset + 4, positions[index + j + 1], true); // y
                dataView.setFloat32(offset + 8, positions[index + j + 2], true); // z
                offset += 12;
            }
            
            // Attribute byte count (2 bytes) - unused in binary STL
            dataView.setUint16(offset, 0, true);
            offset += 2;
        }
        
        // Create a blob from the binary data
        stlContent = new Blob([buffer], { type: 'application/octet-stream' });
        return true;
        
    } catch (error) {
        console.error('Error generating STL:', error);
        return createFallbackSTL();
    }
}
        
    // Create a fallback STL cube if generation fails
    function createFallbackSTL() {
        console.warn('Creating fallback STL cube');
        
        // Create a placeholder STL file (binary format)
        const headerSize = 80;
        const header = new Uint8Array(headerSize);
        
        // Create a simple cube STL with 12 triangles (2 per face)
        const numTriangles = 12;
        const dataSize = 50 * numTriangles;
        const buffer = new ArrayBuffer(headerSize + 4 + dataSize);
        
        const dataView = new DataView(buffer);
        
        // Fill header (80 bytes)
        for (let i = 0; i < headerSize; i++) {
            dataView.setUint8(i, header[i]);
        }
        
        // Number of triangles (4 bytes)
        dataView.setUint32(headerSize, numTriangles, true);
        
        // For the demo, we'll just create a binary blob
        stlContent = new Blob([buffer], { type: 'application/octet-stream' });
        return false;
    }
        
    // Handle download button
    downloadBtn.addEventListener('click', function() {
        if (!stlContent) return;
        
        // Create download link
        const link = document.createElement('a');
        link.href = URL.createObjectURL(stlContent);
        link.download = 'model.stl';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    // Check if embedded in iframe
    const urlParams = new URLSearchParams(window.location.search);
    const isEmbedded = urlParams.get('embedded') === 'true';
    
    // If embedded, hide elements meant for standalone mode
    if (isEmbedded) {
        document.addEventListener('DOMContentLoaded', () => {
            // Hide drop area or other import options
            const dropArea = document.getElementById('drop-area');
            if (dropArea) {
                dropArea.style.display = 'none';
            }
            
            // Hide file input or text area toggle
            const svgTextareaContainer = document.getElementById('svg-textarea-container');
            if (svgTextareaContainer) {
                svgTextareaContainer.style.display = 'none';
            }
            
            // Adjust title or header to indicate embedded mode
            const title = document.querySelector('h1');
            if (title) {
                title.textContent = 'SVG to STL Conversion';
            }
        });
    }
    
    // Listen for SVG data from parent window
    window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'svgData') {
            const svgString = event.data.content;
            
            // Process the SVG
            svgContent = svgString;
            displaySVG(svgContent);
            parseSVG(svgContent);
            
            // Enable convert button
            const convertBtn = document.getElementById('convert-btn');
            if (convertBtn) {
                convertBtn.disabled = false;
            }
        }
    });

    </script>
</body>
</html>
